import { Type, type TSchema, type Static } from '@sinclair/typebox';
import { promises as fs } from 'fs';
import { join } from 'path';
import type { ToolHandler } from '../types/index.js';

const PVSnesLibInitSchema = Type.Object({
  action: Type.Literal('init_project'),
  projectName: Type.String({
    minLength: 1,
    description: 'Project name is required',
  }),
  projectPath: Type.Optional(Type.String({ default: '.' })),
  pvsnesLibVersion: Type.Optional(Type.String({ default: '4.3.0' })),
  includeExamples: Type.Optional(Type.Boolean({ default: true })),
  toolchain: Type.Optional(
    Type.Union([Type.Literal('wla-dx'), Type.Literal('ca65')], {
      default: 'wla-dx',
    })
  ),
});

type PVSnesLibInitParams = Static<typeof PVSnesLibInitSchema>;

async function initProject(params: PVSnesLibInitParams): Promise<string> {
  const {
    projectName,
    projectPath = '.',
    pvsnesLibVersion = '4.3.0',
    includeExamples = true,
    toolchain = 'wla-dx',
  } = params;

  const fullPath = join(process.cwd(), projectPath, projectName);

  // Create project directory structure
  const dirs = [
    'src',
    'assets/graphics',
    'assets/sound',
    'assets/maps',
    'assets/palettes',
    'include',
    'build',
    'out',
    'vendor',
    'tools',
  ];

  for (const dir of dirs) {
    await fs.mkdir(join(fullPath, dir), { recursive: true });
  }

  // Generate project.env configuration file
  const projectEnv = generateProjectEnv(
    projectName,
    pvsnesLibVersion,
    toolchain
  );
  await fs.writeFile(join(fullPath, 'project.env'), projectEnv);

  // Generate main Makefile
  const makefile = generateMakefile(toolchain);
  await fs.writeFile(join(fullPath, 'Makefile'), makefile);

  // Generate skeleton main.c
  const mainC = generateMainC(projectName);
  await fs.writeFile(join(fullPath, 'src', 'main.c'), mainC);

  // Generate user.h and user.c
  const userH = generateUserH();
  await fs.writeFile(join(fullPath, 'src', 'user.h'), userH);

  const userC = generateUserC();
  await fs.writeFile(join(fullPath, 'src', 'user.c'), userC);

  // Generate initial assets Makefile
  const assetsMakefile = generateAssetsMakefile();
  await fs.writeFile(
    join(fullPath, 'assets', 'Makefile.assets'),
    assetsMakefile
  );

  // Generate README
  const readme = generateReadme(projectName, toolchain);
  await fs.writeFile(join(fullPath, 'README.md'), readme);

  // Generate .gitignore
  const gitignore = generateGitignore();
  await fs.writeFile(join(fullPath, '.gitignore'), gitignore);

  // Generate build scripts
  const buildScript = generateBuildScript(toolchain);
  await fs.writeFile(join(fullPath, 'tools', 'build.sh'), buildScript);

  // Make build script executable
  await fs.chmod(join(fullPath, 'tools', 'build.sh'), 0o755);

  if (includeExamples) {
    await generateExampleAssets(fullPath);
  }

  return `‚úÖ SNES project "${projectName}" initialized successfully!

üìÅ Project Structure Created:
  ${projectName}/
  ‚îú‚îÄ‚îÄ src/           # C source files
  ‚îú‚îÄ‚îÄ assets/        # Graphics, sound, maps, palettes  
  ‚îú‚îÄ‚îÄ include/       # Generated headers
  ‚îú‚îÄ‚îÄ build/         # Object files
  ‚îú‚îÄ‚îÄ out/           # Final ROM output
  ‚îú‚îÄ‚îÄ vendor/        # PVSnesLib SDK (use pvsneslib_install_sdk)
  ‚îî‚îÄ‚îÄ tools/         # Build scripts

‚öôÔ∏è  Configuration:
  ‚Ä¢ Toolchain: ${toolchain}
  ‚Ä¢ PVSnesLib version: ${pvsnesLibVersion}
  ‚Ä¢ Examples included: ${includeExamples ? 'Yes' : 'No'}

üöÄ Next Steps:
  1. cd ${projectName}
  2. Run: pvsneslib_validate_host 
  3. Run: pvsneslib_install_sdk
  4. Run: make

Ready to create your 16-bit masterpiece! üéÆ`;
}

function generateProjectEnv(
  projectName: string,
  version: string,
  toolchain: string
): string {
  return `# ${projectName} - PVSnesLib Project Configuration
# Generated by MCP-PVSnesLib

# Project settings
PROJECT_NAME=${projectName}
PROJECT_ROOT=\$(shell pwd)

# PVSnesLib configuration  
PVSNESLIB_VERSION=${version}
PVSNESLIB=\${PROJECT_ROOT}/vendor/pvsneslib-\${PVSNESLIB_VERSION}

# Toolchain selection
TOOLCHAIN=${toolchain}

# Build directories
SRC_DIR=\${PROJECT_ROOT}/src
ASSETS_DIR=\${PROJECT_ROOT}/assets
INCLUDE_DIR=\${PROJECT_ROOT}/include
BUILD_DIR=\${PROJECT_ROOT}/build
OUT_DIR=\${PROJECT_ROOT}/out

# Generated files
ASSET_BUILD=\${ASSETS_DIR}/Makefile.assets
GENERATED_INCLUDE=\${INCLUDE_DIR}
GENERATED_SRC=\${BUILD_DIR}

# Target ROM
TARGET_ROM=\${OUT_DIR}/\${PROJECT_NAME}.sfc

# Compiler settings (will be set by pvsneslib_configure_tools)
CC=
AS=
LD=
CFLAGS=-I\${PVSNESLIB}/include -I\${GENERATED_INCLUDE}
ASFLAGS=
LDFLAGS=

# Asset conversion tools (will be set by pvsneslib_configure_tools)  
GRIT=
PCXCONV=
SNESBRR=
BIN2C=\${PROJECT_ROOT}/tools/bin2c

# Build options
VERBOSE=0
DEBUG=1
OPTIMIZE=0
`;
}

function generateMakefile(toolchain: string): string {
  return `# PVSnesLib Project Makefile
# Generated by MCP-PVSnesLib

# Load project configuration
-include project.env

# Default target
all: \$(TARGET_ROM)

# Include asset build rules (generated by pvsneslib_build_config)
-include \$(ASSET_BUILD)

# Include PVSnesLib build system (after SDK installation)
ifneq (\$(wildcard \$(PVSNESLIB)/lib/build/Makefile.pvsneslib),)
  -include \$(PVSNESLIB)/lib/build/Makefile.pvsneslib
endif

# Source files
C_SOURCES = \$(wildcard \$(SRC_DIR)/*.c)
ASM_SOURCES = \$(wildcard \$(SRC_DIR)/*.asm)

# Object files
C_OBJECTS = \$(patsubst \$(SRC_DIR)/%.c,\$(BUILD_DIR)/%.o,\$(C_SOURCES))
ASM_OBJECTS = \$(patsubst \$(SRC_DIR)/%.asm,\$(BUILD_DIR)/%.o,\$(ASM_SOURCES))
OBJECTS = \$(C_OBJECTS) \$(ASM_OBJECTS)

# Build C objects
\$(BUILD_DIR)/%.o: \$(SRC_DIR)/%.c
	@mkdir -p \$(BUILD_DIR)
	@echo "Compiling \$<"
	\$(CC) \$(CFLAGS) -c \$< -o \$@

# Build ASM objects  
\$(BUILD_DIR)/%.o: \$(SRC_DIR)/%.asm
	@mkdir -p \$(BUILD_DIR)
	@echo "Assembling \$<"
	\$(AS) \$(ASFLAGS) -o \$@ \$<

# Link final ROM
\$(TARGET_ROM): \$(OBJECTS) \$(ASSETS_O)
	@mkdir -p \$(OUT_DIR)
	@echo "Linking \$@"
	\$(LD) \$(LDFLAGS) -o \$@ \$^
	@echo "‚úÖ ROM built: \$@"

# Utility targets
.PHONY: clean run debug validate setup bootstrap

clean:
	@echo "Cleaning build files..."
	rm -rf \$(BUILD_DIR)/* \$(OUT_DIR)/* \$(GENERATED_INCLUDE)/* \$(GENERATED_SRC)/*

run: \$(TARGET_ROM)
	@echo "Running ROM in emulator..."
	@if command -v snes9x >/dev/null 2>&1; then \\
		snes9x \$(TARGET_ROM); \\
	elif command -v zsnes >/dev/null 2>&1; then \\
		zsnes \$(TARGET_ROM); \\
	else \\
		echo "No SNES emulator found. Install snes9x or zsnes."; \\
	fi

debug: \$(TARGET_ROM)
	@echo "Debug info for \$(TARGET_ROM):"
	@ls -la \$(TARGET_ROM)
	@file \$(TARGET_ROM)

validate:
	@echo "Validating project setup..."
	@./tools/build.sh --validate

setup:
	@echo "Running PVSnesLib setup sequence..."
	@echo "This will validate host, install SDK, and configure tools."
	@pvsneslib_bootstrap

bootstrap: setup

help:
	@echo "PVSnesLib Project - Available targets:"
	@echo "  all        - Build the ROM (default)"
	@echo "  clean      - Remove build files"  
	@echo "  run        - Build and run in emulator"
	@echo "  debug      - Show ROM information"
	@echo "  validate   - Validate project setup"
	@echo "  setup      - Run complete PVSnesLib setup"
	@echo "  help       - Show this help"
`;
}

function generateMainC(projectName: string): string {
  return `/*
 * ${projectName} - SNES Game
 * Generated by MCP-PVSnesLib
 */

#include <snes/snes.h>
#include "user.h"

int main(void) {
    // Initialize console
    consoleInit();
    consoleSetTextVram(BG_MAP_BASE(31), BG_TILES_BASE(0), BG_PALETTE(0));
    
    // Set up background modes
    bgSetDisable(2);
    bgSetDisable(1); 
    bgSetDisable(0);
    setMode(BG_MODE1, 0);
    
    // Initialize sprites
    oamInitGfxSet(SPRITES_BASE, 0, OBJ_SIZE16, OBJ_SIZE_16, 0x8000);
    
    // Initialize user code
    user_init();
    
    // Display welcome message
    consoleDrawText(1, 1, "${projectName}");
    consoleDrawText(1, 3, "Built with PVSnesLib!");
    consoleDrawText(1, 4, "Press START to continue...");
    
    // Enable display
    setScreenOn();
    
    // Main game loop
    while (1) {
        // Wait for vertical blank
        WaitForVBlank();
        
        // Update user logic
        user_update();
        
        // Simple controller demo
        scanPads();
        if (padsCurrent(0) & KEY_START) {
            consoleDrawText(1, 6, "START button pressed!");
        }
    }
    
    return 0;
}
`;
}

function generateUserH(): string {
  return `/*
 * User game logic header
 * Add your game-specific declarations here
 */

#ifndef USER_H
#define USER_H

#include <snes/snes.h>

// Game constants
#define SCREEN_WIDTH  256
#define SCREEN_HEIGHT 224

// Function declarations
void user_init(void);
void user_update(void);

// Game state (add your variables here)
extern u16 player_x;
extern u16 player_y;
extern u16 game_score;

#endif /* USER_H */
`;
}

function generateUserC(): string {
  return `/*
 * User game logic implementation
 * Add your game-specific code here
 */

#include "user.h"

// Game state variables
u16 player_x = 128;
u16 player_y = 112;
u16 game_score = 0;

void user_init(void) {
    // Initialize your game state here
    player_x = SCREEN_WIDTH / 2;
    player_y = SCREEN_HEIGHT / 2;
    game_score = 0;
    
    // TODO: Load graphics, set up sprites, etc.
}

void user_update(void) {
    // Update your game logic here
    
    // Example: Simple player movement
    if (padsCurrent(0) & KEY_LEFT && player_x > 8) {
        player_x--;
    }
    if (padsCurrent(0) & KEY_RIGHT && player_x < SCREEN_WIDTH - 8) {
        player_x++;
    }
    if (padsCurrent(0) & KEY_UP && player_y > 8) {
        player_y--;
    }
    if (padsCurrent(0) & KEY_DOWN && player_y < SCREEN_HEIGHT - 8) {
        player_y++;
    }
    
    // TODO: Update sprites, collision detection, etc.
}
`;
}

function generateAssetsMakefile(): string {
  return `# Asset Build Rules
# Generated by MCP-PVSnesLib
# This file will be populated by pvsneslib_build_config

# Asset object files (populated by build system)
ASSETS_O =

# Default target
assets: \$(ASSETS_O)

# Clean assets
clean-assets:
	@echo "Cleaning generated assets..."
	rm -f \$(GENERATED_INCLUDE)/*.h
	rm -f \$(GENERATED_SRC)/*.c \$(GENERATED_SRC)/*.o

.PHONY: assets clean-assets

# Asset build rules will be generated here by pvsneslib_build_config
# based on your MCP tool outputs (sprites, tilemaps, palettes, sound)
`;
}

function generateReadme(projectName: string, toolchain: string): string {
  return `# ${projectName}

A Super Nintendo Entertainment System (SNES) game built with PVSnesLib and MCP-PVSnesLib tools.

## üéÆ Getting Started

### Prerequisites
- PVSnesLib SDK (will be installed automatically)
- ${toolchain} toolchain (will be configured automatically)
- SNES emulator (snes9x recommended)

### Quick Setup
\`\`\`bash
# Validate your system
pvsneslib_validate_host

# Install PVSnesLib SDK
pvsneslib_install_sdk

# Configure toolchain
pvsneslib_configure_tools

# Build the ROM
make

# Run in emulator
make run
\`\`\`

### Or use the bootstrap command:
\`\`\`bash
pvsneslib_bootstrap
make
\`\`\`

## üìÅ Project Structure

- \`src/\` - C source code and assembly files
- \`assets/\` - Graphics, sound, maps, and palettes
- \`include/\` - Generated header files
- \`build/\` - Compiled object files
- \`out/\` - Final ROM output
- \`vendor/\` - PVSnesLib SDK installation
- \`tools/\` - Build scripts and utilities

## üõ†Ô∏è Development Workflow

1. **Create Assets**: Use MCP tools to generate sprites, tilemaps, etc.
   \`\`\`bash
   sprite_manager({ action: "create_sprite_template", spriteName: "player" })
   tilemap_generator({ action: "create_tilemap", levelName: "level1" })
   \`\`\`

2. **Generate Build Rules**: Update Makefile with asset dependencies
   \`\`\`bash
   pvsneslib_build_config
   \`\`\`

3. **Build and Test**:
   \`\`\`bash
   make clean
   make
   make run
   \`\`\`

## üéØ Available Make Targets

- \`make\` - Build the ROM
- \`make clean\` - Remove build files
- \`make run\` - Build and run in emulator
- \`make debug\` - Show ROM information
- \`make validate\` - Validate project setup

## üîß Configuration

Project settings are stored in \`project.env\`. This file is automatically generated and updated by the PVSnesLib tools.

## üìö Resources

- [PVSnesLib Documentation](https://github.com/alekmaul/pvsneslib)
- [MCP-PVSnesLib Tools](https://github.com/user/mcp-pvsneslib)
- [SNES Development Resources](https://snes.nesdev.org/)

## üèÜ Happy Coding!

Ready to create the next great 16-bit masterpiece! üéÆ‚ú®
`;
}

function generateGitignore(): string {
  return `# Build outputs
build/
out/
include/
*.sfc
*.smc

# PVSnesLib installation
vendor/

# IDE files
.vscode/
*.swp
*.swo
*~

# System files
.DS_Store
Thumbs.db

# Temporary files
*.tmp
*.bak
*.log

# Generated files
Makefile.assets
project.env.bak
`;
}

function generateBuildScript(toolchain: string): string {
  return `#!/bin/bash
# Build script for PVSnesLib project
# Generated by MCP-PVSnesLib

set -e

PROJECT_ROOT="\$(cd "\$(dirname "\${BASH_SOURCE[0]}")/.." && pwd)"
cd "\$PROJECT_ROOT"

# Load configuration
if [ -f project.env ]; then
    source project.env
fi

# Colors for output
RED='\\033[0;31m'
GREEN='\\033[0;32m'
YELLOW='\\033[1;33m'
BLUE='\\033[0;34m'
NC='\\033[0m' # No Color

log_info() {
    echo -e "\${BLUE}[INFO]\${NC} \$1"
}

log_success() {
    echo -e "\${GREEN}[SUCCESS]\${NC} \$1"
}

log_warning() {
    echo -e "\${YELLOW}[WARNING]\${NC} \$1"
}

log_error() {
    echo -e "\${RED}[ERROR]\${NC} \$1"
}

validate_setup() {
    log_info "Validating project setup..."
    
    # Check if PVSnesLib is installed
    if [ ! -d "\$PVSNESLIB" ]; then
        log_error "PVSnesLib not found at \$PVSNESLIB"
        log_info "Run: pvsneslib_install_sdk"
        return 1
    fi
    
    # Check if tools are configured
    if [ -z "\$CC" ] || [ ! -x "\$(command -v "\$CC")" ]; then
        log_error "Compiler not found or not configured"
        log_info "Run: pvsneslib_configure_tools"
        return 1
    fi
    
    log_success "Project setup is valid"
    return 0
}

build_project() {
    log_info "Building \${PROJECT_NAME}..."
    
    if ! validate_setup; then
        return 1
    fi
    
    # Build with make
    if make "\$@"; then
        log_success "Build completed: \${TARGET_ROM}"
        
        # Show ROM info
        if [ -f "\${TARGET_ROM}" ]; then
            log_info "ROM size: \$(stat -c%s "\${TARGET_ROM}" 2>/dev/null || stat -f%z "\${TARGET_ROM}" 2>/dev/null || echo "unknown") bytes"
        fi
    else
        log_error "Build failed"
        return 1
    fi
}

# Parse command line arguments
case "\${1:-build}" in
    "validate" | "--validate")
        validate_setup
        ;;
    "build" | "--build" | "")
        build_project "\${@:2}"
        ;;
    "clean" | "--clean")
        log_info "Cleaning build files..."
        make clean
        log_success "Clean completed"
        ;;
    "help" | "--help" | "-h")
        echo "Usage: \$0 [command]"
        echo "Commands:"
        echo "  build     - Build the project (default)"
        echo "  validate  - Validate project setup"
        echo "  clean     - Clean build files"
        echo "  help      - Show this help"
        ;;
    *)
        log_error "Unknown command: \$1"
        echo "Use '\$0 help' for available commands"
        exit 1
        ;;
esac
`;
}

async function generateExampleAssets(projectPath: string): Promise<void> {
  // Generate a simple example sprite config
  const exampleSprite = {
    name: 'player_example',
    size: '16x16',
    colorDepth: '4bpp',
    animationFrames: 4,
  };

  await fs.writeFile(
    join(projectPath, 'assets', 'graphics', 'player_example.json'),
    JSON.stringify(exampleSprite, null, 2)
  );

  // Generate example tilemap config
  const exampleTilemap = {
    name: 'level1_example',
    width: 32,
    height: 28,
    tileSize: '8x8',
    includeCollision: true,
  };

  await fs.writeFile(
    join(projectPath, 'assets', 'maps', 'level1_example.json'),
    JSON.stringify(exampleTilemap, null, 2)
  );

  // Generate example palette config
  const examplePalette = {
    name: 'main_palette',
    colors: ['#000000', '#FFFFFF', '#FF0000', '#00FF00', '#0000FF'],
    colorMode: '4bpp',
  };

  await fs.writeFile(
    join(projectPath, 'assets', 'palettes', 'main_palette.json'),
    JSON.stringify(examplePalette, null, 2)
  );
}

export const pvsnesLibInitTool: ToolHandler = {
  name: 'pvsneslib_init',
  description:
    'Initialize a new PVSnesLib SNES development project with proper structure, Makefile, and skeleton code',
  parameters: [
    {
      name: 'action',
      type: 'string',
      description: 'The action to perform (must be "init_project")',
      required: true,
    },
    {
      name: 'projectName',
      type: 'string',
      description: 'Name of the SNES project to create',
      required: true,
    },
    {
      name: 'projectPath',
      type: 'string',
      description: 'Directory path where the project will be created',
      required: false,
    },
    {
      name: 'pvsnesLibVersion',
      type: 'string',
      description: 'PVSnesLib version to target (default: 4.3.0)',
      required: false,
    },
    {
      name: 'includeExamples',
      type: 'boolean',
      description: 'Include example asset configurations',
      required: false,
    },
    {
      name: 'toolchain',
      type: 'string',
      description: 'Toolchain to use: wla-dx or ca65 (default: wla-dx)',
      required: false,
    },
  ],
  execute: async (params: any) => {
    try {
      // Validate required parameters
      if (!params.projectName || params.projectName.trim() === '') {
        throw new Error('Project name is required');
      }

      if (params.action !== 'init_project') {
        throw new Error('Invalid action. Must be "init_project"');
      }

      const result = await initProject(params as PVSnesLibInitParams);
      return {
        success: true,
        content: result,
        metadata: {
          projectName: params.projectName,
          toolchain: params.toolchain || 'wla-dx',
          pvsnesLibVersion: params.pvsnesLibVersion || '4.3.0',
          timestamp: new Date().toISOString(),
        },
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  },
};
